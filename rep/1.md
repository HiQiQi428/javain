### 1.HashMap和ConcurrentHashMap的区别
ConcurrentHashMap通过分段锁支持并发,而HashMap只有通过modCount来检测并发修改,并不能支持并发操作.HashMap的synchronized版本
!!!
### 2.HashMap内部具体如何实现的
HashMap用Node数组存储数据,Node是Map.Entry的实现,通过Node中的next字段实现一个链表,用于存储Hash冲突的数据.HashMap通过异或key.hashCode的高16位和低16位获取key哈希值,再用这个哈希值去获取元素在Node数组中的索引,通过索引获取到链表实现的桶,然后遍历桶找到目标元素,进行get或put操作.
### 3.如果hashMap的key是一个自定义的类，怎么办
重写自定义类的equals和hashCode方法
### 4.为什么重写equals还要重写hashcode
因为HashMap根据key查找元素时有这样的判断:```if (node.key == key || node.hash == hash && node.key.equals(key))```,这里node.hash和hash两个变量都是通过key.hashCode生成的.
### 5.ArrayList和LinkedList的区别，如果一直在list的尾部添加元素，用哪个效率高？
ArrayList用Object[]存储数据,每次添加数据前检查容量,如果容量不够根据策略计算需要的容量,然后创建新数组将原来的数据拷贝到新数组中.而LinkedList通过双向列表存储数据,每次尾部添加数据都要修改节点关系,但没有扩容操作.对ArrayList在容量增长初期,由于需要拷贝的数据少,扩容付出的时间代价小,通过索引添加数据较LinkedList更快.在容量增长后期,每次扩容都要拷贝一个大数组,付出的时间大,这时LinkedList效率更高.
### 6.介绍一下Syncronized锁。如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？
synchronized是最基本的互斥同步手段,其对应字节码:monitorenter和monitorexit,这两个字节码都需要一个reference类型的参数来指明要锁定的和解锁的对象.
synchronized是相同线程可重入的,每进入一次锁计数器加1,考虑在同一条线程的synchronized块中递归.
synchronized导致的线程阻塞和唤醒会造成内核态与用户态的切换,所以synchronized是一个重量级操作.
ReetrantLock相比synchronized多了:等待可中断,可实现公平锁,锁可绑定多个条件.
* 普通同步方法,锁是当前实例对象
* 静态同步方法,锁是当前类的class对象
* 同步方法块,锁是括号里面的对象
### 7.介绍一下volatile
volatile是JVM提供的最轻量级的同步机制,将变量定义为volatile后,它具备两种特性:
##### 1.保证变量可见性:即当一条线程修改了这个变量的值,新值对于其他线程来说是可以立即得知的.
执行引擎在使用volatile变量前先进行刷新,所以执行引擎看不到不一致的情况.
但是基于volatile变量的运算在并发下并不是安全的.因为Java的运算并非原子操作,即在变量使用过程中可能出现值过期的情况,有如下代码:
<pre><code>public class TestVolatile {
    volatile int a = 1;
    void increase() {
        a++;
    }
}
</code></pre>
代码编译后的increase方法:
<pre><code>
0:  getstatic
1:  iconst_1
2:  iadd
3:  putstatic
4:  return
</code></pre>
在执行iconst_1和iadd这些指令时,可能已经有其他线程改变了a并写回了主内存,这时当前线程栈顶值就已经过期了(一条字节码本身可能被编译成多条机器指令).
volatile使用场景:
* 运算结果不依赖变量的当前值,或者能保证只有单一线程修改变量的值
* 变量不需要与其他的状态变量共同参与不变约束
##### 2.禁止指令重排序优化
普通变量仅仅保证在所有依赖赋值结果的地方都能获取到正确的结果,而不能保证变量赋值操作顺序与程序代码中的执行顺序一致.举例,如果一个线程共享的信号变量没有volatile修饰,可能由于指令重排序导致某个赋值操作提前执行,结果是其他线程提前接收到信号.
### 8.多线程中的i++线程安全吗？为什么？
不安全.假设i是一个volatile变量,那么在每次有线程执行i++时对先从主内存获取i的最新值,然后进行运算,由于运算非原子性,在运算过程中可能有其他线程已经修改过i,导致当前线程工作内存中的i值已经过期,所以i++不是线程安全的.如果i只是普通变量,连使用前刷新都没有,那就更不是线程安全的了.
### 9.如何线程安全的实现一个计数器？
一是用synchronized实现计数方法的互斥访问,一是用AtomicInteger进行计数
### 10.讲一下TCP的连接和释放连接。
https://www.cnblogs.com/newwy/p/3234536.html
##### 1.建立连接
主机B运行一个服务器进程,发出一个被动打开命令,告诉它的TCP要准备接收客户进程的连续请求,然后服务进程就处于监听状态,不断检测是否有客户进程发起连续请求.客户进程运行在主机A中,先向自己的TCP发出主动打开的命令,表明要向某个IP地址的某个端口建立运输连接,详细过程为:
* 1.主机A向主机B发出连接请求报文段,其同步比特syn=1,同时选择一个序号seq=x表明期待接受的数据字节序号;
* 2.主机B收到连接请求报文段后,如果同意,则发回确认报文,其同步比特syn=1,确认号ack=x+1,也发送一个期待数据字节序号seq=y;
* 3.主机A收到确认报文后,也发送一个确认报文,确认号为ack=y+1;
* 4.主机A和B的TCP通知上层应用进程,连接建立.
##### 2.释放连接
* 1.数据传输结束后,主机A的应用进程先向其TCP发出释放连接请求,不再发送数据.TCP发送释放连接报文给主机B,FIN=1,seq=u(已传送数据的最后一个字节的序号+1);
* 2.主机B的TCP收到释放连接通知后发出确认报文,seq=u+1,同时通知应用进程,这样A到B的连接就释放了.这时连接处于半关闭状态,主机B不再接收主机A发来的数据,但主机B还在向主机A发送数据,主机A若正确接受数据仍需要发送确认;
* 3.主机B向主机A发送数据结束后,其应用进程就通知TCP释放连接.主机B的连接释放报文置FIN=1,seq=w=前面传送过的数据的最后一个字节的序号+1,ack=u+1;
* 4.主机A对主机B的连接释放报文发出确认,ACK=1,ack=w+1,seq=u+1,这样B到A的连接就释放了,主机A的TCP再想其应用进程报告连接已经全部释放.
### 11.讲一下浏览器从接收到一个URL到最后展示出页面，经历了哪些过程。
* 浏览器发送HTTP报文,报文包含URL解析出的主机名,访问路径和参数.
* 通过DNS服务器查询主机名对应的IP地址,然后与服务器建立TCP连接,再发送HTTP报文到服务器;
* 服务器与客户端建立连接后,TCP接受到HTTP报文,提交给上层服务器应用程序,这里拿tomcat举例.tomcat解析HTTP报文构造HttpRequest对象,根据访问路径匹配servlet,由servlet处理,然后发送HTTP响应报文;
* 客户端收到HTTP响应报文,解析响应报文的html对象中的资源引用,对这些资源引用首先查询web缓存,如果不在缓存中则发送一个HTTP请求报文请求对应资源;如果存在缓存中发送一个HEAD方法的HTTP报文比较服务器对应资源的最后更新时间,如果缓存资源已过期则再发送请求报文重新加载资源,不然则直接使用本地缓存;
### 12.长连接怎么实现的
HTTP/1.1起默认使用长连接,在HTTP响应头加入```Connection:keep-alive```,当一个网页打开完成后,TCP连接不会关闭,客户端后续的访问会继续使用这一条连接.但连接不会用就保持,它有一个保持时间.
### 13.GC工具用过哪些？
<b>JConsole和JvisualVM</b>
!!!
### 14.讲一下什么情况可以影响到新生代的回收速度。
可能在存活对象比较多的情况下,Survivor空间不足,需要移动对象到老年代.
!!!
### 15.JVM老年代回收速度为什么比新生代慢很多很多？
##### 1.分类
GC分为Yong GC,Old GC,MIXED GC,Full GC几种,也有分为Minor GC,Major GC,Full GC的.
##### 2.分工
Yong GC回收新生代.
Old GC回收老年代,个别JVM参数配置设置了Old GC之前必须执行一次Yong GC.
MIXED GC回收新生代和老年代,G1回收算法.
Full GC回收新生代,老年代,元数据区(永久代).
##### 3.为什么Full GC比Yong GC和Old GC慢?
* 虚拟机规范中Class回收条件苛刻,永生代回收算法效率低
* 多回收了方法区,增加了总回收耗时
* Full GC本身不会先进行Minor GC,而老年代许多对象都会引用到新生代的对象,先进性一次Minor GC可以提高老年代GC速度(G1除外)
* G1发生了concurrent mode fail后退化成了单线程回收整个堆.
##### 4.为什么老年代垃圾回收效率比新生代低很多?
* 从并行和并发机制,并行和并发的默认线程数上可以看出,-XX:ConcGCThreads=(-XX:ParallelGCThreads + 3) / 4
* 新生代复制算法比较快,Eden区回收时直接全部清空,存活对象存放到内存容量比较小的Survivor,少了内存碎片整理,加上直接copy的速度,效率很高.以空间换时间.
* 卡表数据结构,卡表为一个比特位的集合,卡表中每一位表示老年代4KB的空间,每一个比特位可以用来表示老年代某一区域中的所有对象是否持有新生代对象的引用.这样新生代GC时不用花大量时间扫描所有老年代对象来确定每一个对象的引用关系,只需要扫描卡表标记位为1的区域.
* 老年代MS算法会导致内存碎片化,因此引入MC算法,执行完毕后,存活的对象会按序放置,移动对象的内存地址,来解决碎片化,但执行时间较长.时间换空间.
* 老年代内存容量一般较大,回收需要预留比较大的空间,这样内存利用率就低.
### 16.如何回收堆外直接内存?
JVM使用一个后台线程,通过虚引用遍历堆中已经被回收的对象对直接内存的直接引用,显式地调用free()方法释放直接内存,Full GC不能直接释放堆外直接内存,堆外直接内存的释放和GC方式无关.
### 17.写SQL：找出每个城市的最新一条记录
> id 城市 人口 信息 创建时间
1 北京 100 info1 时间戳
2 北京 100 info2 时间戳
3 上海 100 info3 时间戳
4 上海 100 info4 时间戳
<pre><code>select * from
record as r1 
join (select city, max(timestamp) as timestamp from record group by city) as r2
on r1.city = r2.city and r1.timestamp = r2.timestamp;
</code></pre>
### 18.编程题：写一个函数，找到一个文件夹下所有文件，包括子文件夹。
<pre><code>private void ergodic(String path) {
    File base = new File(path);
    if (!base.exists())
        throw new IllegalArgumentException();
    if (base.isDirectory())
        ergodic(base, 0);
    else
        System.out.println(base.getName());
}

public void ergodic(File base, int depth) { 
    for (int i = 0; i < depth; i++)
        System.out.print(' ');
    System.out.println(base.getName());
    if (base.isDirectory()) {
        for (File file : base.listFiles())
            ergodic(file, depth + 2);
    }
}
</code></pre>
### 19.淘宝的目录树，设计数据库的表和字段
### 21.为什么选用springboot框架？
### 23.springboot框架源码看过吗？hashMap的源码看过吗？
### 24.学习中遇见了什么问题让你感觉印象最深刻？
### 25.情景题：如果一个外卖配送单子要发布，现在有200个骑手都想要接这一单，如何保证只有一个骑手接到单子？
为订单表添加状态字段,标识订单是否已被接,在第一个骑手接单后,修改订单状态.基于数据库的ACID特性,可以保证只有这一个骑手接到单.
### 26.分布式集群中如何保证线程安全？
https://blog.csdn.net/cutesource/article/details/5791350
！！！
### 27.介绍一下TCP的三次握手？每次发送了什么信号？如果去掉最后一次握手会怎样？
第一次SYN=1,seq=x
第二次SYN=1,ACK=1,ack=x+1,seq=y
第三次SYN=1,ACK=1,ack=y+1,seq=x+1
如果去掉最后一次握手,服务器将无法得知是否客户机接受到了连接响应报文,即无法得知连接是否建立成功,也就无法进行后续的数据传输了.
### 28.TCP协议在哪一层？IP协议在那一层？HTTP在哪一层？
TCP在传输层,IP在网络层,HTTP在应用层.
### 29.数据库索引介绍一下。介绍一下什么时候用Innodb什么时候用MyISAM。
https://www.cnblogs.com/zlcxbb/p/5757245.html
MySQL主要有四种类型的索引:B-Tree索引,Hash索引,Fulltext索引和R-Tree索引.
B-Tree索引是MySQL数据库中使用最频繁的索引类型,所有实际需要的数据都存放于Tree的Leaf Node,而且到任何一个Leaf Node的最短路径的长度都是相同的.
Innodb存储引擎的B-Tree索引实际使用的存储结构是B+Tree,在每个Leaf Node上面除了存放索引键的相关信息外,还存储了指向该Leaf Node相邻后一个Leaf Node的指针.
### 30.介绍一下聚簇索引和非聚簇索引
聚簇索引如Innodb索引和数据一体,B+Tree的Leaf Node存放的是数据记录本身,而不是记录地址,而索引和数据分离的方式既是非聚簇索引.
### 32.知道什么设计模式
接口模式，职责型模式，构造型模式，操作型模式，扩展型模式
### 33.介绍一下单例模式？懒汉式的单例模式如何实现单例？
单例模式即一个类加载后只会存在一个实例.懒汉式单例模式可以在获取实例时,判断实例句柄是否为NULL,然后决定是否进行一次初始化.在并发情景下,可以是用DCL单例模式,即在判断实例句柄为NULL后,加锁重新判断,以避免其他线程已经初始化获得了实例.不过我偶然在网上看到过一篇对DCL问题得探讨,即有可能其他线程正在初始化类,这时当前线程发现了变化,判断句柄不为空,导致返回未初始化完得实例,这种情况可以将初始化操作中涉及赋值操作得变量声明为final或者volatile.
思考:并发情景下初始化一个类,调用其构造函数也是多线程的吧,但是将对象赋值给对象引用不应该一定在构造结束之后吗?对想究竟如何初始化的,了解一下!
### 34.介绍一下策略模式
把可互换的方法封装在各自独立的类中，并且让每个方法都实现一个公共的操作。
* 策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类
* 重心：策略模式的重心不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更加灵活，具有更好的维护性和扩展i性
* 平等性：各个策略的平等性，是的算法之间可以相互替换，所有算法的实现上也应该是相互独立的，没有相互依赖的
* 唯一性：每一个时刻只能使用一个具体的策略实现对象
* 共有行为：所有具体策略类都有一些公有的行为，这些行为被抽象到抽象策略角色Strategy类中