### 1.HashMap和ConcurrentHashMap的区别
ConcurrentHashMap通过分段锁支持并发,而HashMap只有通过modCount来检测并发修改,并不能支持并发操作.HashMap的synchronized版本
...
### 2.HashMap内部具体如何实现的
HashMap用Node数组存储数据,Node是Map.Entry的实现,通过Node中的next字段实现一个链表,用于存储Hash冲突的数据.HashMap通过异或key.hashCode的高16位和低16位获取key哈希值,再用这个哈希值去获取元素在Node数组中的索引.!!!
### 3.如果hashMap的key是一个自定义的类，怎么办
重写自定义类的equals和hashCode方法
### 4.为什么重写equals还要重写hashcode
因为HashMap根据key查找元素时有这样的判断:```if (node.key == key || node.hash == hash && node.key.equals(key))```,这里node.hash和hash两个变量都是通过key.hashCode生成的.
### 5.ArrayList和LinkedList的区别，如果一直在list的尾部添加元素，用哪个效率高？
ArrayList用Object[]存储数据,每次添加数据前检查容量,如果容量不够根据策略计算需要的容量,然后创建新数组将原来的数据拷贝到新数组中.而LinkedList通过双向列表存储数据,每次尾部添加数据都要修改节点关系,但没有扩容操作.对ArrayList在容量增长初期,由于需要拷贝的数据少,扩容付出的时间代价小,通过索引添加数据较LinkedList更快.在容量增长后期,每次扩容都要拷贝一个大数组,付出的时间大,这时LinkedList效率更高.
### 6.介绍一下Syncronized锁。如果用这个关键字修饰一个静态方法，锁住了什么？如果修饰成员方法，锁住了什么？
synchronized是最基本的互斥同步手段,其对应字节码:monitorenter和monitorexit,这两个字节码都需要一个reference类型的参数来指明要锁定的和解锁的对象.
synchronized是相同线程可重入的,每进入一次锁计数器加1,考虑在同一条线程的synchronized块中递归.
synchronized导致的线程阻塞和唤醒会造成内核态与用户态的切换,所以synchronized是一个重量级操作.
ReetrantLock相比synchronized多了:等待可中断,可实现公平锁,锁可绑定多个条件.
* 普通同步方法,锁是当前实例对象
* 静态同步方法,锁是当前类的class对象
* 同步方法块,锁是括号里面的对象
### 7.介绍一下volatile
volatile是JVM提供的最轻量级的同步机制,将变量定义为volatile后,它具备两种特性:
##### 1.保证变量可见性:即当一条线程修改了这个变量的值,新值对于其他线程来说是可以立即得知的.
执行引擎在使用volatile变量前先进行刷新,所以执行引擎看不到不一致的情况.
但是基于volatile变量的运算在并发下并不是安全的.因为Java的运算并非原子操作,即在变量使用过程中可能出现值过期的情况,有如下代码:
<pre><code>public class TestVolatile {
    volatile int a = 1;
    void increase() {
        a++;
    }
}
</code></pre>
代码编译后的increase方法:
<pre><code>
0:  getstatic
1:  iconst_1
2:  iadd
3:  putstatic
4:  return
</code></pre>
在执行iconst_1和iadd这些指令时,可能已经有其他线程改变了a并写回了主内存,这时当前线程栈顶值就已经过期了(一条字节码本身可能被编译成多条机器指令).
volatile使用场景:
* 运算结果不依赖变量的当前值,或者能保证只有单一线程修改变量的值
* 变量不需要与其他的状态变量共同参与不变约束
##### 2.禁止指令重排序优化
普通变量仅仅保证在所有依赖赋值结果的地方都能获取到正确的结果,而不能保证变量赋值操作顺序与程序代码中的执行顺序一致.举例,如果一个线程共享的信号变量没有volatile修饰,可能由于指令重排序导致某个赋值操作提前执行,结果是其他线程提前接收到信号.
### 8.多线程中的i++线程安全吗？为什么？
不安全.假设i是一个volatile变量,那么在每次有线程执行i++时对先从主内存获取i的最新值,然后进行运算,由于运算非原子性,在运算过程中可能有其他线程已经修改过i,导致当前线程工作内存中的i值已经过期,所以i++不是线程安全的.如果i只是普通变量,连使用前刷新都没有,那就更不是线程安全的了.
### 9.如何线程安全的实现一个计数器？
一是用synchronized实现计数方法的互斥访问,一是用AtomicInteger进行计数
### 10.讲一下TCP的连接和释放连接。
https://www.cnblogs.com/newwy/p/3234536.html
##### 1.建立连接
主机B运行一个服务器进程,发出一个被动打开命令,告诉它的TCP要准备接收客户进程的连续请求,然后服务进程就处于监听状态,不断检测是否有客户进程发起连续请求.客户进程运行在主机A中,先向自己的TCP发出主动打开的命令,表明要向某个IP地址的某个端口建立运输连接,详细过程为:
* 1.主机A向主机B发出连接请求报文段,其同步比特syn=1,同时选择一个序号seq=x表明期待接受的数据字节序号;
* 2.主机B收到连接请求报文段后,如果同意,则发回确认报文,其同步比特syn=1,确认号ack=x+1,也发送一个期待数据字节序号seq=y;
* 3.主机A收到确认报文后,也发送一个确认报文,确认号为ack=y+1;
* 4.主机A和B的TCP通知上层应用进程,连接建立.
##### 2.释放连接
* 1.数据传输结束后,主机A的应用进程先向其TCP发出释放连接请求,不再发送数据.TCP发送释放连接报文给主机B,FIN=1,seq=u(已传送数据的最后一个字节的序号+1);
* 2.主机B的TCP收到释放连接通知后发出确认报文,seq=u+1,同时通知应用进程,这样A到B的连接就释放了.这时连接处于半关闭状态,主机B不再接收主机A发来的数据,但主机B还在向主机A发送数据,主机A若正确接受数据仍需要发送确认;
* 3.主机B向主机A发送数据结束后,其应用进程就通知TCP释放连接.主机B的连接释放报文置FIN=1,seq=w=前面传送过的数据的最后一个字节的序号+1,ack=u+1;
* 4.主机A对主机B的连接释放报文发出确认,ACK=1,ack=w+1,seq=u+1,这样B到A的连接就释放了,主机A的TCP再想其应用进程报告连接已经全部释放.
### 11.讲一下浏览器从接收到一个URL到最后展示出页面，经历了哪些过程。
* 浏览器发送HTTP报文,报文包含URL解析出的主机名,访问路径和参数.
* 通过DNS服务器查询主机名对应的IP地址,然后与服务器建立TCP连接,再发送HTTP报文到服务器;
* 服务器与客户端建立连接后,TCP接受到HTTP报文,提交给上层服务器应用程序,这里拿tomcat举例.tomcat解析HTTP报文构造HttpRequest对象,根据访问路径匹配servlet,由servlet处理,然后发送HTTP响应报文;
* 客户端收到HTTP响应报文,解析响应报文的html对象中的资源引用,对这些资源引用首先查询web缓存,如果不在缓存中则发送一个HTTP请求报文请求对应资源;如果存在缓存中发送一个HEAD方法的HTTP报文比较服务器对应资源的最后更新时间,如果缓存资源已过期则再发送请求报文重新加载资源,不然则直接使用本地缓存;
### 12.长连接怎么实现的